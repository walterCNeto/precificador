
\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{amsmath, amssymb, amsthm, mathtools}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{enumitem}
\geometry{margin=1in}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, urlcolor=blue}

\lstdefinestyle{pystyle}{
  language=Python,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue!70!black}\bfseries,
  commentstyle=\color{green!40!black}\itshape,
  stringstyle=\color{red!60!black},
  showstringspaces=false,
  breaklines=true,
  frame=single,
  rulecolor=\color{black!25},
  tabsize=2
}

\title{\textbf{derivx} --- Precificador de Derivativos por \emph{Building Blocks}\\
\large Monte Carlo (MC) + LSMC + DSL Declarativa}
\author{Walter C. Neto (repo: \url{https://github.com/walterCNeto/precificador})}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
\texttt{derivx} é uma biblioteca leve e extensível para precificação de derivativos em Python.
A arquitetura separa claramente: (i) \emph{modelo sob medida risco-neutro} (gerador de trajetórias),
(ii) \emph{numerário/curva} (desconto), (iii) \emph{payoffs} como funcionais de trajetória (PF) componíveis,
e (iv) \emph{política de exercício} (Europeu/Bermudano/Americano via LSMC).
Uma DSL declarativa (JSON/dict) permite especificar produtos sem escrever código novo.
O pacote inclui exemplos, testes e CI. Este documento descreve teoria, API e exemplos de uso.
\end{abstract}

\section{Instalação e \emph{quick start}}
\begin{verbatim}
# ambiente (Windows PowerShell)
python -m venv .venv && .\.venv\Scripts\Activate.ps1
pip install -e .[dev]
pytest -q
python examples/european_call.py
\end{verbatim}

\paragraph{Exemplo mínimo (via DSL).}
\begin{lstlisting}[style=pystyle]
from derivx import price_from_spec, bs_call_price

spec = {
    "model": {"r": 0.05, "q": [0.0], "sigma": [0.2], "corr": [[1.0]]},
    "grid": {"T": 1.0, "steps": 64},
    "S0": [100.0],
    "product": {"style": "european", "type": "european_call", "asset": 0, "K": 100.0},
    "n_paths": 80_000, "seed": 123,
}
price, se = price_from_spec(spec)
print("MC:", price, "±", 1.96*se)
print("BS:", bs_call_price(100, 100, r=0.05, q=0.0, sigma=0.2, T=1.0))
\end{lstlisting}

\section{Arquitetura}
\begin{itemize}[leftmargin=1.2em]
\item \textbf{Curva (numerário):} classe \texttt{PiecewiseFlatCurve} implementa $r(t)$ \emph{piecewise-flat}, com integral
exata por trechos e desconto $DF(t_0,t_1)=\exp\{-\int_{t_0}^{t_1} r(u)\,du\}$.
\item \textbf{Modelo sob $\mathbb{Q}$ (GBM multiativo):} \texttt{RiskNeutralGBM} simula $D$ ativos com dividendos $q_i(t)$, volatidades
$\sigma_i(t)$ e correlação $\rho$ (Cholesky). Dinâmica:
\begin{equation}
\frac{dS_i}{S_i} = (r(t)-q_i(t))\,dt + \sigma_i(t)\, dW_i^{\mathbb{Q}}(t), \quad i=1,\dots,D.
\end{equation}
\item \textbf{Funcionais de trajetória (PF):} utilitários vetorizados para acessar $S_{t_k}$, máximo/mínimo \emph{running},
médias, cestas, e barreiras tocadas. Payoffs são apenas funções \verb|paths -> np.ndarray|.
\item \textbf{Motor MC:} \texttt{MonteCarloEngine.price} avalia $E_{\mathbb{Q}}[\,\text{payoff(paths)}\,]\cdot DF(0,T)$
com variância reduzida (antitético, e CV opcional).
\item \textbf{Exercício (LSMC):} \texttt{MonteCarloEngine.price\_exercisable} implementa Longstaff--Schwartz:
regressão do valor de continuidade em \emph{features} de estado para datas discretas de exercício.
\item \textbf{DSL:} módulo \texttt{dsl.spec} mapeia um dicionário JSON para engine, grade temporal e produto
(\texttt{european/basket/asian/up-and-out}; \texttt{bermudan/american} via \texttt{exercise\_every}/\texttt{exercise\_idx}).
\end{itemize}

\section{Teoria resumida}
\subsection{Precificação sob $\mathbb{Q}$}
Para payoff $X$ em $T$, com numerário banco $B(t)=\exp\{\int_0^t r(u)\,du\}$,
\begin{equation}
\Pi_0 = \mathbb{E}^{\mathbb{Q}}\!\left[\frac{X}{B(T)}\right] = DF(0,T)\cdot \mathbb{E}^{\mathbb{Q}}[X].
\end{equation}
No MC, estimamos $\hat \Pi_0 = DF(0,T)\,\overline{X}$ com erro padrão $\mathrm{SE}=\frac{s_X}{\sqrt{N}}$ e IC 95\% $\pm 1.96\cdot \mathrm{SE}$.

\subsection{LSMC (Longstaff--Schwartz)}
Para American/Bermudana com payoff imediato $g(S_{t_k})$ e conjunto de exercício $\mathcal{T}=\{t_{k_j}\}$:
\begin{enumerate}[nosep]
\item Simule trajetórias $\{S^{(n)}_{t_k}\}$.
\item Retropropague $k$ decrescendo: estime $C_k(s)\approx \mathbb{E}[V_{k{+}}|S_{t_k}=s]$ por regressão (base polinomial sobre \emph{features}).
\item Em cada caminho: exerça em $t_k$ se $g(S_{t_k})\ge C_k(S_{t_k})$ e ainda não exerceu.
\item Desconte o fluxo exercido à origem e faça a média.
\end{enumerate}
Implementamos \emph{features} padrão como $\log S_{t_k}$ dos ativos e base polinomial até grau 2 (com cruzados).

\section{API (Python)}
\subsection{Curva e modelo}
\begin{lstlisting}[style=pystyle]
import numpy as np
from derivx import PiecewiseFlatCurve, RiskNeutralGBM, MonteCarloEngine

r_curve = PiecewiseFlatCurve(np.array([1e-8]), np.array([0.05]))  # 5% a.a.
model = RiskNeutralGBM(r_curve, q_funcs=[0.0], sigma_funcs=[0.2], corr=None)
eng = MonteCarloEngine(model)
\end{lstlisting}

\subsection{Payoffs como funções (PF)}
\begin{lstlisting}[style=pystyle]
from derivx import PF, relu

# Lookback call (fixed-strike): max_t S_t - K
def lookback_call(asset: int, K: float):
    return lambda paths: relu(PF.running_max(paths, asset) - K)

# Range digital: paga 1 se S_T in [L,U]
def range_digital(asset: int, L: float, U: float):
    return lambda paths: ((PF.terminal(paths, asset) >= L) &
                          (PF.terminal(paths, asset) <= U)).astype(float)
\end{lstlisting}

\subsection{Motor MC (europeias e path-dependentes)}
\begin{lstlisting}[style=pystyle]
times = np.linspace(0.0, 1.0, 64+1)
S0 = [100.0]
payoff = lookback_call(0, K=100.0)
price, se = eng.price(payoff, S0, times, n_paths=120_000, seed=7)
print(price, "±", 1.96*se)
\end{lstlisting}

\subsection{Exercício (Bermudana/Americana) via LSMC}
\begin{lstlisting}[style=pystyle]
from derivx import ExerciseSpec, PF, relu

def imm_put(paths, k):
    St = PF.at_time(paths, 0, k)
    return relu(100.0 - St)

# exercicio trimestral (em uma grade de 64 passos/ano)
exercise_idx = [16, 32, 48, 64]  # inclui o final
spec = ExerciseSpec(exercise_idx=exercise_idx, immediate_payoff=imm_put)

price, se = eng.price_exercisable(spec, S0, times, n_paths=150_000, seed=1)
\end{lstlisting}

\subsection{DSL declarativa}
\begin{lstlisting}[style=pystyle]
from derivx import price_from_spec

spec = {
  "model": {"r": 0.05, "q": [0.0], "sigma": [0.2], "corr": [[1.0]]},
  "grid": {"T": 1.0, "steps": 64},
  "S0": [100.0],
  "product": {"style":"european", "type":"up_and_out_call",
              "asset":0, "K":100.0, "barrier":130.0},
  "n_paths": 40_000, "seed": 123
}
p, se = price_from_spec(spec)
\end{lstlisting}

\paragraph{Chaves suportadas (resumo).}
\begin{itemize}[leftmargin=1.2em]
\item \texttt{model}: \texttt{r} ou \texttt{r\_curve=\{times,rates\}}, \texttt{q}, \texttt{sigma}, \texttt{corr}.
\item \texttt{grid}: \texttt{T}, \texttt{steps}.
\item \texttt{S0}: lista de preços iniciais (1 por ativo).
\item \texttt{product}: \texttt{style} $\in$ \{\texttt{european}, \texttt{bermudan}, \texttt{american}\};
\texttt{type} $\in$ \{\texttt{european\_call}, \texttt{european\_put}, \texttt{asian\_arith\_call},
\texttt{up\_and\_out\_call}, \texttt{basket\_call}\}. Bermudana/americana usa
\texttt{exercise\_every}/\texttt{exercise\_idx}/\texttt{exercise\_times}.
\item \texttt{n\_paths}, \texttt{seed}.
\end{itemize}

\section{Métodos Numéricos}
\subsection{Simulação}
Usamos discretização \emph{exact log-Euler} para GBM: no passo $(t_k,t_{k+1})$,
\begin{equation}
S_{t_{k+1}} = S_{t_k}\,\exp\!\Big((r-q-\tfrac12\sigma^2)\Delta t + \sigma\sqrt{\Delta t}\,Z\Big),
\end{equation}
com vetor gaussiano correlacionado via Cholesky.
Antitético é aplicado duplicando $Z$ por $-Z$.
\subsection{Variância e erro}
O estimador é não-viesado; a incerteza é reportada por $\mathrm{SE}$ e IC 95\%.
Para europeias com fórmula fechada (ex.: Black--Scholes), pode-se usar \emph{control variate} para reduzir a variância.
\subsection{Greeks}
O pacote oferece \emph{bump-and-revalue} com common random numbers (CRN) (implemente externo com os mesmos \texttt{seed}/\texttt{times}).
Extensões naturais: estimadores \emph{pathwise} e \emph{LRM}.
\subsection{Curva piecewise-flat}
A integral $\int r(u)\,du$ é exata por trechos; o último trecho se estende até $+\infty$.
Isso evita o acúmulo de erro de quadratura e garante desconto correto até $T$.

\section{Extensões}
\paragraph{Novos modelos.} Adicione \texttt{models/heston.py} com método \texttt{simulate\_paths} mantendo a mesma assinatura;
o motor e payoffs seguem inalterados.
\paragraph{Novos payoffs.} Crie funções \verb|paths -> array| combinando PF (\texttt{running\_max}, \texttt{average}, \texttt{basket},
\texttt{barrier\_touched}) e combinadores (\texttt{relu}, \texttt{where}).
\paragraph{Barreiras e rebates.} Compose barreira (\texttt{barrier\_touched}) para anular ou adicionar rebate.
\paragraph{Quanto / multi-ativo.} Use \texttt{basket} envolvendo ativo e FX; desconte na moeda alvo.
\paragraph{PDE/FFT (futuro).} Um backend PDE 1D para American vanilla e FFT (Carr--Madan) para europeias podem compartilhar a mesma DSL.

\section{Testes e validação}
\begin{itemize}[leftmargin=1.2em]
\item \textbf{Consistência BS}: call europeia aproxima Black--Scholes.
\item \textbf{Paridade put--call}: $C - P = S_0 e^{-qT} - K e^{-rT}$ (dentro da tolerância MC).
\item \textbf{Monotonicidades e ordens}: Bermudana $\ge$ Europeia (mesmo payoff), up-and-out $\le$ vanilla.
\end{itemize}

\section{Exemplos adicionais}
\subsection{Asiática aritmética}
\begin{lstlisting}[style=pystyle]
spec = {
  "model": {"r": 0.05, "q": [0.0], "sigma": [0.2], "corr": [[1.0]]},
  "grid": {"T": 1.0, "steps": 64}, "S0": [100.0],
  "product": {"style": "european", "type": "asian_arith_call", "asset": 0, "K": 100.0},
  "n_paths": 60_000, "seed": 7
}
p, se = price_from_spec(spec)
\end{lstlisting}

\subsection{Basket call 2D}
\begin{lstlisting}[style=pystyle]
spec = {
  "model": {"r": 0.05, "q": [0.01, 0.03], "sigma": [0.20, 0.30],
            "corr": [[1.0,0.5],[0.5,1.0]]},
  "grid": {"T": 2.0, "steps": 80}, "S0": [100.0, 120.0],
  "product": {"style":"european", "type":"basket_call", "weights":[0.5,0.5], "K": 110.0},
  "n_paths": 80_000, "seed": 3
}
p, se = price_from_spec(spec)
\end{lstlisting}

\subsection{Put Bermudano (LSMC)}
\begin{lstlisting}[style=pystyle]
spec = {
  "model": {"r":0.05, "q":[0.0], "sigma":[0.2], "corr":[[1.0]]},
  "grid": {"T":1.0, "steps":64}, "S0":[100.0],
  "product": {"style":"bermudan", "type":"european_put", "asset":0,
              "K":100.0, "exercise_every":16},
  "n_paths": 120_000, "seed": 4
}
p, se = price_from_spec(spec)
\end{lstlisting}

\section{Estrutura do repositório (sugestão)}
\begin{verbatim}
derivx/
├─ pyproject.toml
├─ LICENSE.txt
├─ README.md
├─ src/derivx/
│  ├─ __init__.py
│  ├─ curves.py
│  ├─ models/gbm.py
│  ├─ engine/montecarlo.py
│  ├─ exercise/lsmc.py
│  ├─ payoffs/core.py
│  └─ dsl/spec.py
├─ tests/
│  ├─ test_bs_consistency.py
│  ├─ test_properties.py
│  └─ test_put_call_parity.py
└─ examples/
   ├─ european_call.py
   └─ smoke.py
\end{verbatim}

\section{Licença e aviso}
O código é fornecido sob MIT. Uso acadêmico/educacional; valide premissas e riscos antes de produção.

\section*{Referências (sucintas)}
\noindent
Black, F.; Scholes, M. (1973). The Pricing of Options and Corporate Liabilities. \emph{Journal of Political Economy}.\\
Longstaff, F.; Schwartz, E. (2001). Valuing American Options by Simulation: A Simple Least-Squares Approach. \emph{Review of Financial Studies}.\\
Margrabe, W. (1978). The Value of an Option to Exchange One Asset for Another. \emph{Journal of Finance}.
\end{document}
