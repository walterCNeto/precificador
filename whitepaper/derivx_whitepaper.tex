\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{amsmath, amssymb, amsthm, mathtools}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{enumitem}
\geometry{margin=1in}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, urlcolor=blue}

\lstdefinestyle{pystyle}{
  language=Python,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue!70!black}\bfseries,
  commentstyle=\color{green!40!black}\itshape,
  stringstyle=\color{red!60!black},
  showstringspaces=false,
  breaklines=true,
  frame=single,
  rulecolor=\color{black!25},
  tabsize=2
}

\title{\textbf{derivx} --- Precificador de Derivativos por \emph{Building Blocks}\\
\large MC/LSMC, PDE Crank--Nicolson e FFT (Heston) com DSL Declarativa}
\author{Walter C. Neto (repo: \url{https://github.com/walterCNeto/precificador})}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
\texttt{derivx} é uma biblioteca leve e extensível para precificação de derivativos em Python.
A arquitetura separa: (i) \emph{modelo sob risco-neutro} (gerador de trajetórias),
(ii) \emph{numerário/curva} (desconto determinístico), (iii) \emph{payoffs} como funcionais de trajetória (PF) componíveis,
e (iv) \emph{política de exercício} (Europeu/Bermudano/Americano via LSMC).
Uma DSL declarativa (JSON/dict) permite especificar produtos sem escrever código novo.
Inclui backends MC (GBM/Heston), PDE 1D (Crank--Nicolson) para vanillas e FFT (Carr--Madan) para Heston europeu.
Exemplos, testes e CI acompanham o pacote. Este documento traz teoria, API, guias de uso e exemplos.
\end{abstract}

\tableofcontents

\section{Instalação e \emph{quick start}}
\begin{verbatim}
# Windows PowerShell
python -m venv .venv
.\.venv\Scripts\Activate.ps1
pip install -e ".[dev]"
pytest -q
python examples/smoke.py
\end{verbatim}

\paragraph{Exemplo mínimo (via DSL).}
\begin{lstlisting}[style=pystyle]
from derivx import price_from_spec, bs_call_price

spec = {
  "engine": "mc",
  "model": {"name":"gbm","r":0.05,"q":0.0,"sigma":0.2},
  "grid": {"T": 1.0, "steps": 128},
  "S0": [100.0],
  "product": {"style":"european","type":"european_call","asset":0,"K":100.0},
  "n_paths": 80_000, "seed": 42,
}
p, se = price_from_spec(spec)
print("MC:", p, "±", 1.96*se)
print("BS:", bs_call_price(100, 100, r=0.05, q=0.0, sigma=0.2, T=1.0))
\end{lstlisting}

\section{Arquitetura (visão geral)}
\begin{itemize}[leftmargin=1.2em]
\item \textbf{Curva (numerário).} \texttt{PiecewiseFlatCurve} implementa $r(t)$ \emph{piecewise-flat} com desconto
$DF(t_0,t_1)=\exp\{-\int_{t_0}^{t_1} r(u)\,du\}$ exato por trechos.
\item \textbf{Modelos sob $\mathbb{Q}$.} 
GBM multiativo (\texttt{RiskNeutralGBM}) com $q_i(t)$, $\sigma_i(t)$ e correlação, e Heston para europeias (MC/FFT).
\item \textbf{Funcionais de trajetória (PF).} Utilitários vetorizados: $S_{t_k}$, máximos/mínimos corridos, médias, barreiras, cestas.
Payoffs são funções \verb|paths -> np.ndarray|.
\item \textbf{Motores numéricos.} 
\emph{MC}: simulação e estimação $E_{\mathbb Q}[X]$ (antitético e CV opcionais).
\emph{PDE CN}: 1D para calls/puts; exercício americano via projeção $\max$ por passo de tempo.
\emph{FFT (Heston)}: Carr--Madan com parâmetros $\alpha$, $N$, $\eta$.
\item \textbf{Exercício (LSMC).} \texttt{ExerciseSpec} + \texttt{lsmc.price}: regressão do valor de continuação em features (por padrão $\log S$,
base polinomial até grau 2 + cruzados).
\item \textbf{DSL.} \texttt{price\_from\_spec(spec)} mapeia um dicionário JSON para engine, grade temporal e produto.
\end{itemize}

\section{Base teórica}

\subsection{Precificação sob $\mathbb{Q}$ e numeraire}
Seja $B(t)=\exp\{\int_0^t r(u)\,du\}$ o banco. Para payoff $X$ em $T$:
\[
\Pi_0=\mathbb E^{\mathbb Q}\!\left[\frac{X}{B(T)}\right]=DF(0,T)\,\mathbb E^{\mathbb Q}[X].
\]
No MC estimamos $\hat \Pi_0 = DF(0,T)\,\overline{X}$ com erro-padrão 
$\mathrm{SE}=s_X/\sqrt{N}$ e IC 95\% como $\pm 1.96\,\mathrm{SE}$.

\subsection{GBM multiativo e simulação exata}
Para $i=1,\dots,D$:
\[
\frac{dS_i}{S_i}=(r(t)-q_i(t))\,dt+\sigma_i(t)\,dW_i^{\mathbb Q}(t),\quad
\mathrm{Cov}(dW_i,dW_j)=\rho_{ij}\,dt.
\]
No passo $\Delta t$: 
\[
S_{t+\Delta t} = S_t\exp\!\Big((r-q-\tfrac12\sigma^2)\Delta t + \sigma\sqrt{\Delta t}\,Z\Big),
\]
com $Z\sim \mathcal N(0,\rho)$ via Cholesky. Antitético usa $Z$ e $-Z$.
\emph{Bias} temporal é $\mathcal O(\Delta t)$ para payoffs path-dependentes; use \texttt{steps} adequados.

\subsection{LSMC (Longstaff--Schwartz)}
Datas de exercício $\mathcal T=\{t_{k_j}\}$; payoff imediato $g(S_{t_k})$.
Seja $V_k$ o valor ótimo ao tempo $t_k$ e $\tau$ a \emph{stopping time} ótima.
Define-se o valor de continuação:
\[
C_k(s)=\mathbb E\!\big[\,DF(t_k,t_{k+1})\,V_{k+1}\,\big|\,S_{t_k}=s\big].
\]
O algoritmo:
\begin{enumerate}[nosep]
\item Simule caminhos $S^{(n)}_{t_k}$.
\item No vencimento $t_{k^\star}$, $V^{(n)}=g(S^{(n)}_{t_{k^\star}})$.
\item Para $k$ decrescendo nos tempos de exercício: estime $C_k$ por regressão (apenas nos ITM).
\item Em cada caminho, exerça em $t_k$ se $g(S_{t_k})\ge \widehat C_k(S_{t_k})$.
\end{enumerate}
\textbf{Cuidados práticos}: (i) restringir regressão ao ITM; (ii) usar desconto correto entre janelas ($\Delta t$ possivelmente múltiplas); 
(iii) evitar overfit (cross-fit A/B); (iv) checar monotonia: Bermudan densificando $\Rightarrow$ aproxima Americano.

\subsection{PDE 1D Crank--Nicolson (vanillas)}
Para um ativo sob GBM, a PDE de Black--Scholes para $V(S,t)$:
\[
\partial_t V + (r-q)S\,\partial_S V + \tfrac12\sigma^2 S^2 \partial^2_{SS}V - rV = 0.
\]
CN discretiza implicitamente em $t$ e centralmente em $S$, levando a um sistema tridiagonal por passo.
\textbf{Condições de contorno} usuais:
\begin{itemize}[nosep,leftmargin=1.2em]
\item \emph{Call}: $V(0,t)=0$; $V(S_{\max},t)\approx S_{\max}e^{-q(T-t)}-Ke^{-r(T-t)}$.
\item \emph{Put}: $V(0,t)\approx Ke^{-r(T-t)}$; $V(S_{\max},t)\to 0$.
\end{itemize}
\textbf{Americano}: após resolver o passo, projeta-se $V\gets\max(V,\,\text{payoff imediato})$.
\textbf{Convergência}: $\mathcal O(\Delta t + \Delta S^2)$. Aumentar \texttt{NS}, \texttt{NT} e \texttt{Smax\_mult} melhora acurácia.

\subsection{FFT (Heston europeu)}
Em Heston, precificação por Carr--Madan calcula preços via a transformada de Fourier do payoff amortecido por $\alpha>0$:
\[
C(K) = \frac{e^{-\alpha k}}{\pi}\int_0^\infty \Re\!\big( e^{-iu k}\,\psi(u)\big)\,du,\quad k=\ln K.
\]
Com discretização uniforme em frequência ($\eta$) e tamanho de malha $N$,
uma FFT retorna uma grade de preços para diversos \emph{strikes}. Parâmetros:
\begin{itemize}[nosep,leftmargin=1.2em]
\item $\alpha$ (damping, típico $1.0$--$2.0$), 
\item $N$ (tamanho da FFT, potência de 2),
\item $\eta$ (passo em frequência; governa espaçamento em strikes).
\end{itemize}

\section{Como usar a biblioteca}

\subsection{Camada 1 — API direta (curvas, modelos, motores)}
\begin{lstlisting}[style=pystyle]
import numpy as np
from derivx import PiecewiseFlatCurve, RiskNeutralGBM, MonteCarloEngine

# Curva "piecewise-flat": 5% a.a.
r_curve = PiecewiseFlatCurve(np.array([1e-8]), np.array([0.05]))

# Modelo GBM monofator
model = RiskNeutralGBM(r_curve, q_funcs=[0.0], sigma_funcs=[0.2], corr=None)
eng = MonteCarloEngine(model)

# Grade temporal e S0
times = np.linspace(0.0, 1.0, 128+1)
S0 = [100.0]

# Payoff europeu: call
from derivx import PF, relu
payoff = lambda paths: relu(PF.terminal(paths, asset=0) - 100.0)

price, se = eng.price(payoff, S0, times, n_paths=80_000, seed=42)
print(price, "±", 1.96*se)
\end{lstlisting}

\paragraph{Exercício via LSMC.}
\begin{lstlisting}[style=pystyle]
from derivx import ExerciseSpec

def imm_put(paths, k):
    St = PF.at_time(paths, asset=0, idx=k)
    return relu(100.0 - St)

exercise_idx = [16, 32, 48, 64]  # inclui vencimento
spec = ExerciseSpec(exercise_idx=exercise_idx, immediate_payoff=imm_put)

price, se = eng.price_exercisable(spec, S0, times, n_paths=150_000, seed=7)
\end{lstlisting}

\subsection{Camada 2 — DSL declarativa (\texttt{price\_from\_spec})}
\begin{lstlisting}[style=pystyle]
from derivx import price_from_spec

spec = {
  "engine":"mc",  # "mc" | "pde" | "fft"
  "model":{"name":"gbm","r":0.05,"q":0.0,"sigma":0.2},
  "grid":{"T":1.0,"steps":128},   # PDE usa só T
  "S0":[100.0],
  "product":{"style":"european","type":"european_call","asset":0,"K":100.0},
  "n_paths":80_000,"seed":7
}
price, se = price_from_spec(spec)
\end{lstlisting}

\paragraph{Chaves suportadas.}
\begin{itemize}[leftmargin=1.2em]
\item \texttt{engine}: \verb|"mc"|, \verb|"pde"|, \verb|"fft"|.
\item \texttt{model}:
\begin{itemize}[nosep]
\item GBM: \verb|{"name":"gbm","r":..., "q":..., "sigma":...}|.
\item Heston: \verb|{"name":"heston","r":...,"q":...,"kappa":...,"theta":...,"xi":...,"rho":...,"v0":...}|.
\end{itemize}
\item \texttt{grid}: \verb|{"T":..., "steps":...}| (MC); PDE usa \verb|{"T":...}|.
\item \texttt{S0}: lista de preços iniciais.
\item \texttt{product}:
\begin{itemize}[nosep]
\item Vanilla: \verb|european_call|, \verb|european_put|.
\item Path-dep.: \verb|asian_arith_call|, \verb|up_and_out_call|.
\item Exercício: \verb|{"style":"bermudan","type":"european_put","exercise_every":16}|.
\end{itemize}
\item Parâmetros do motor: MC (\verb|n_paths|, \verb|seed|), PDE (\verb|NS|, \verb|NT|, \verb|Smax_mult|),
FFT (\verb|alpha|, \verb|N|, \verb|eta|).
\end{itemize}

\subsection{Precisão \& Performance: \emph{knobs} práticos}
\begin{center}
\begin{tabular}{@{}llp{7.5cm}@{}}
\toprule
Backend & Parâmetro & Efeito prático \\
\midrule
MC & \texttt{n\_paths} & SE $\propto 1/\sqrt{N}$; mais paths $\Rightarrow$ erro menor (custo linear). \\
MC & \texttt{steps} & Menor bias temporal em path-dep./LSMC; custo $\propto$ paths $\times$ steps. \\
MC & \texttt{seed} & Reprodutibilidade (use CRN p/ Greeks). \\
PDE & \texttt{NS, NT} & Convergência $\mathcal O(\Delta t + \Delta S^2)$; aumente malha até estabilizar. \\
PDE & \texttt{Smax\_mult} & Domínio $[0, S_{\max}]$; use 5–7 vezes o strike como regra inicial. \\
FFT & $\alpha$ & Damping (1–2 típico). Muito baixo/alto pode instabilizar. \\
FFT & $N$, $\eta$ & Resolução em frequência/strike; aumente $N$ para malha mais densa. \\
\bottomrule
\end{tabular}
\end{center}

\section{Validação, testes e reprodutibilidade}
\begin{itemize}[leftmargin=1.2em]
\item \textbf{Consistência BS}: MC (GBM) $\approx$ Black--Scholes (dentro de $k\cdot\mathrm{SE}$).
\item \textbf{PDE vs BS}: put europeu CN $\approx$ BS; americano PDE $\ge$ europeu.
\item \textbf{Propriedades}: up\&out $\le$ vanilla; Bermudan com janelas mais densas $\nearrow$ American.
\item \textbf{Heston}: MC $\approx$ FFT (tolerância baseada em SE).
\end{itemize}
\begin{verbatim}
# Windows
$env:PYTEST_DISABLE_PLUGIN_AUTOLOAD="1"
python -m pytest -q
\end{verbatim}

\section{Exemplos práticos (fim-a-fim)}

\subsection{(E1) Europeu: MC vs Black--Scholes}
\begin{lstlisting}[style=pystyle]
from math import exp
from derivx import price_from_spec, bs_call_price

S0=K=100.0; r=0.05; q=0.0; sigma=0.2; T=1.0
spec = {"engine":"mc","model":{"name":"gbm","r":r,"q":q,"sigma":sigma},
        "grid":{"T":T,"steps":128},"S0":[S0],
        "product":{"style":"european","type":"european_call","asset":0,"K":K},
        "n_paths":80_000,"seed":42}
pmc,se = price_from_spec(spec)
pbs = bs_call_price(S0,K,r,q,sigma,T)
print(f"MC={pmc:.4f} ± {1.96*se:.4f} | BS={pbs:.4f}")
\end{lstlisting}

\subsection{(E2) PDE: put europeu vs americano}
\begin{lstlisting}[style=pystyle]
from derivx import price_from_spec
euro={"engine":"pde","model":{"name":"gbm","r":0.05,"q":0.0,"sigma":0.2},
      "grid":{"T":1.0},"S0":[100.0],
      "product":{"style":"european","type":"european_put","asset":0,"K":100.0},
      "NS":800,"NT":800,"Smax_mult":5.0}
amer={**euro,"product":{"style":"american","type":"european_put","asset":0,"K":100.0}}
pe,_ = price_from_spec(euro); pa,_ = price_from_spec(amer)
print(f"PDE euro={pe:.4f}  PDE amer={pa:.4f}  (amer >= euro)")
\end{lstlisting}

\subsection{(E3) Barreira up\&out e monotonia}
\begin{lstlisting}[style=pystyle]
base={"engine":"mc","model":{"name":"gbm","r":0.05,"q":0.0,"sigma":0.2},
      "grid":{"T":1.0,"steps":128},"S0":[100.0],"n_paths":100_000,"seed":7}
van,_  = price_from_spec({**base,"product":{"style":"european","type":"european_call","asset":0,"K":100.0}})
uo130,_= price_from_spec({**base,"product":{"style":"european","type":"up_and_out_call","asset":0,"K":100.0,"barrier":130.0}})
uo140,_= price_from_spec({**base,"product":{"style":"european","type":"up_and_out_call","asset":0,"K":100.0,"barrier":140.0}})
print(f"UO130={uo130:.4f} <= UO140={uo140:.4f} <= Vanilla={van:.4f}")
\end{lstlisting}

\subsection{(E4) Asiática aritmética $\le$ vanilla}
\begin{lstlisting}[style=pystyle]
asian,_= price_from_spec({**base,"product":{"style":"european","type":"asian_arith_call","asset":0,"K":100.0}})
print(f"Asian={asian:.4f} <= Vanilla={van:.4f}")
\end{lstlisting}

\subsection{(E5) Bermudana (LSMC): frequência de exercício}
\begin{lstlisting}[style=pystyle]
def berm(ex_every):
  spec={"engine":"mc","model":{"name":"gbm","r":0.05,"q":0.0,"sigma":0.2},
        "grid":{"T":1.0,"steps":256},"S0":[100.0],
        "product":{"style":"bermudan","type":"european_put","asset":0,"K":100.0,"exercise_every":ex_every},
        "n_paths":120_000,"seed":7}
  return price_from_spec(spec)
for ex in (8,16,32):
  p,se = berm(ex)
  print(f"ex_every={ex:>2}: {p:.4f} ± {1.96*se:.4f}")
\end{lstlisting}

\subsection{(E6) Heston: FFT vs MC}
\begin{lstlisting}[style=pystyle]
common={"name":"heston","r":0.05,"q":0.0,"kappa":1.5,"theta":0.04,"xi":0.5,"rho":-0.7,"v0":0.04}
fft={"engine":"fft","model":common,"grid":{"T":1.0},"S0":[100.0],
     "product":{"style":"european","type":"european_call","asset":0,"K":100.0},
     "alpha":1.5,"N":4096,"eta":0.25}
mc={"engine":"mc","model":common,"grid":{"T":1.0,"steps":512},"S0":[100.0],
    "product":{"style":"european","type":"european_call","asset":0,"K":100.0},
    "n_paths":200_000,"seed":7}
p_fft,_=price_from_spec(fft); p_mc,se=price_from_spec(mc)
print(f"FFT={p_fft:.4f} | MC={p_mc:.4f} ± {1.96*se:.4f}")
\end{lstlisting}

\subsection{(E7) Basket 2D (GBM correlacionado)}
\begin{lstlisting}[style=pystyle]
spec={"engine":"mc",
      "model":{"name":"gbm","r":0.05,"q":[0.01,0.03],"sigma":[0.20,0.30],
               "corr":[[1.0,0.5],[0.5,1.0]]},
      "grid":{"T":2.0,"steps":80},"S0":[100.0,120.0],
      "product":{"style":"european","type":"basket_call","weights":[0.5,0.5],"K":110.0},
      "n_paths":100_000,"seed":3}
p,se=price_from_spec(spec)
print(p, "±", 1.96*se)
\end{lstlisting}

\subsection{(E8) Greeks por \emph{bump \& revalue} (CRN)}
\begin{lstlisting}[style=pystyle]
import numpy as np
base={"engine":"mc","model":{"name":"gbm","r":0.05,"q":0.0,"sigma":0.2},
      "grid":{"T":1.0,"steps":256},"S0":[100.0],
      "product":{"style":"european","type":"european_call","asset":0,"K":100.0},
      "n_paths":120_000,"seed":11}
def price(spec): from derivx import price_from_spec; return price_from_spec(spec)[0]
h=1.0
p0=price(base)
pU=price({**base,"S0":[100.0+h]})
pD=price({**base,"S0":[100.0-h]})
delta=(pU-pD)/(2*h); gamma=(pU-2*p0+pD)/(h*h)
print("Delta~",delta,"Gamma~",gamma)
\end{lstlisting}

\section{Estrutura do repositório (resumo)}
\begin{verbatim}
src/derivx/
  curves.py           # PiecewiseFlatCurve (df, ints)
  models/gbm.py       # RiskNeutralGBM (paths; df via curva)
  engine/montecarlo.py
  engine/pde.py       # CN 1D vanillas (euro/amer)
  engine/fft.py       # Heston FFT (Carr-Madan)
  exercise/lsmc.py    # LSMC genérico
  payoffs/core.py     # PF utilitários (terminal, média, etc.)
  dsl/spec.py         # mapeia dict -> engine/produto
tests/                # sanity e propriedades
examples/             # scripts reprodutíveis
\end{verbatim}

\section{Licença e aviso}
MIT. Uso acadêmico/educacional; valide premissas, calibração e risco de modelo antes de produção.

\section*{Referências}
\noindent
Black, F.; Scholes, M. (1973) \emph{The Pricing of Options and Corporate Liabilities}.\\
Longstaff, F.; Schwartz, E. (2001) \emph{Valuing American Options by Simulation}.\\
Carr, P.; Madan, D. (1999) \emph{Option Valuation Using the FFT}.\\
Heston, S. (1993) \emph{A Closed-Form Solution for Options with Stochastic Volatility}.\\
Margrabe, W. (1978) \emph{The Value of an Option to Exchange One Asset for Another}.
\end{document}